<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>毫秒级甘特图 - AntV X6 实现</title>
  <script src="https://unpkg.com/@antv/x6/dist/index.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    #container {
      width: 100%;
      height: 600px;
      border: 1px solid #eee;
      margin-bottom: 20px;
    }
    .controls {
      margin: 15px 0;
      display: flex;
      gap: 20px;
      align-items: center;
    }
    .time-display {
      font-family: monospace;
      background: #f5f5f5;
      padding: 5px 10px;
      border-radius: 4px;
    }
    .zoom-value {
      min-width: 40px;
      display: inline-block;
      text-align: center;
    }
  </style>
</head>
<body>
<h1>毫秒级精度甘特图</h1>
<div class="controls">
  <div>
    <label>缩放比例:
      <input type="range" id="zoom-slider" min="0.1" max="2" step="0.1" value="1">
      <span id="zoom-value" class="zoom-value">1.0</span>x
    </label>
  </div>
  <div>
    当前时间: <span id="current-time" class="time-display">2023-01-01 00:00:00.000</span>
  </div>
  <button id="add-task">添加随机任务</button>
</div>
<div id="container"></div>

<script>
  // 1. 初始化画布
  const graph = new X6.Graph({
    container: document.getElementById('container'),
    grid: {
      visible: true,
      size: 10,
      type: 'doubleMesh',
      args: [
        { color: '#eee', thickness: 1 },
        { color: '#ddd', thickness: 1, factor: 5 }
      ]
    },
    panning: { enabled: true },
    mousewheel: { enabled: false, modifiers: ['ctrl', 'meta'] }
  });

  // 2. 时间处理工具
  const parseTime = (timeStr) => {
    const [datePart, timePart] = timeStr.split(' ');
    const [hh, mm, ss] = timePart.split(':');
    const [seconds, milliseconds] = ss.split('.');
    return new Date(`${datePart}T${hh}:${mm}:${seconds}.${milliseconds}Z`);
  };

  const formatTime = (date) => {
    const iso = date.toISOString();
    return iso.replace('T', ' ').replace('Z', '').slice(0, 23);
  };

  // 3. 生成测试数据
  const generateRandomTask = (id) => {
    const startMs = Math.floor(Math.random() * 3000);
    const durationMs = 200 + Math.floor(Math.random() * 1000);
    return {
      id: 'task-' + id,
      name: `任务-${id}`,
      text: `任务-${id}`,
      color: `hsl(${Math.random() * 360}, 70%, 60%)`,
      ranges: [
        {
          start: formatTime(new Date(baseTime.getTime() + startMs)),
          end: formatTime(new Date(baseTime.getTime() + startMs + durationMs))
        }
      ]
    };
  };

  const baseTime = parseTime('2023-01-01 00:00:00.000');
  let tasks = Array.from({ length: 3 }, (_, i) => generateRandomTask(i + 1));

  // 4. 比例尺控制
  let pixelsPerMillisecond = 1;
  const updateZoomValue = () => {
    document.getElementById('zoom-value').textContent = pixelsPerMillisecond.toFixed(1);
  };

  // 5. 主渲染函数
  function renderGantt() {
    graph.clearCells();

    // 计算时间范围
    const allTimes = tasks.flatMap(t => t.ranges.flatMap(r => [
      parseTime(r.start),
      parseTime(r.end)
    ]));
    const minTime = new Date(Math.min(...allTimes));
    const maxTime = new Date(Math.max(...allTimes));
    const totalMs = maxTime - minTime;

    // 绘制时间轴背景
    graph.addNode({
      shape: 'rect',
      x: 0,
      y: tasks.length * 50 + 20,
      width: totalMs * pixelsPerMillisecond,
      height: 40,
      attrs: {
        body: { fill: '#f9f9f9', stroke: '#ddd' }
      }
    });

    // 绘制时间刻度
    for (let ms = 0; ms <= totalMs; ms += 100) {
      const time = new Date(minTime.getTime() + ms);
      const x = (time - baseTime) * pixelsPerMillisecond;

      // 刻度线
      graph.addNode({
        shape: 'rect',
        x,
        y: tasks.length * 50 + 20,
        width: 1,
        height: ms % 500 === 0 ? 20 : 10,
        attrs: { body: { fill: ms % 500 === 0 ? '#666' : '#999' } }
      });

      // 刻度标签（每500ms）
      if (ms % 500 === 0) {
        graph.addNode({
          shape: 'rect',
          x,
          y: tasks.length * 50 + 65,
          label: formatTime(time).split(' ')[1],
          attrs: {
            label: {
              fontSize: 10,
              fill: '#666',
              textAnchor: 'middle'
            }
          }
        });
      }
    }

    // 绘制任务条
    tasks.forEach((task, taskIndex) => {
      task.ranges.forEach((range, rangeIndex) => {
        const startX = (parseTime(range.start) - baseTime) * pixelsPerMillisecond;
        const endX = (parseTime(range.end) - baseTime) * pixelsPerMillisecond;
        const width = endX - startX;

        graph.addNode({
          id: `${task.id}-${rangeIndex}`,
          shape: 'rect',
          x: startX,
          y: taskIndex * 50,
          width,
          height: 30,
          attrs: {
            body: {
              fill: task.color,
              stroke: '#333',
              rx: 4,
              ry: 4,
              cursor: 'move'
            },
            label: {
              text: rangeIndex === 0 ? task.name : '',
              fill: '#fff',
              fontSize: 12,
              x: 6,
              y: 15
            }
          },
          data: {
            taskId: task.id,
            rangeIndex,
            start: range.start,
            end: range.end
          }
        });

        // 显示时间段标签
        if (width > 60) {
          graph.addNode({
            shape: 'rect',
            x: startX + width / 2,
            y: taskIndex * 50 + 15,
            label: `${(width / pixelsPerMillisecond).toFixed(0)}ms`,
            attrs: {
              label: {
                fill: '#fff',
                textAnchor: 'middle',
                fontWeight: 'bold'
              }
            }
          });
        }
      });
    });

    // 添加实时时钟标记
    const now = new Date();
    const nowX = (now - baseTime) * pixelsPerMillisecond;
    if (!graph.getCellById('clock-marker')) {
      graph.addNode({
        id: 'clock-marker',
        shape: 'path',
        x: nowX,
        y: -10,
        attrs: {
          path: {
            d: 'M 0 0 L 0 1000',
            stroke: 'red',
            strokeWidth: 2
          },
          text: {
            text: 'NOW',
            fill: 'red',
            fontSize: 12,
            y: -15,
            textAnchor: 'middle'
          }
        }
      });
    }
    document.getElementById('current-time').textContent = formatTime(now);
  }

  // 6. 交互功能
  graph.on('node:moved', ({ node }) => {
    if (!node?.data('start')) return;

    const duration = parseTime(node.data('end')) - parseTime(node.data('start'));
    const newStart = new Date(baseTime.getTime() + node.position().x / pixelsPerMillisecond);
    const newEnd = new Date(newStart.getTime() + duration);

    // 更新节点数据
    node.data({
      start: formatTime(newStart),
      end: formatTime(newEnd)
    });

    // 更新任务数据
    const task = tasks.find(t => t.id === node.data('taskId'));
    if (task) {
      task.ranges[node.data('rangeIndex')] = {
        start: node.data('start'),
        end: node.data('end')
      };
    }
  });

  // 7. 缩放控制
  document.getElementById('zoom-slider').addEventListener('input', (e) => {
    pixelsPerMillisecond = parseFloat(e.target.value);
    updateZoomValue();
    renderGantt();
  });

  // 8. 添加随机任务
  document.getElementById('add-task').addEventListener('click', () => {
    tasks.push(generateRandomTask(tasks.length + 1));
    renderGantt();
  });

  // 9. 键盘快捷键
  document.addEventListener('keydown', (e) => {
    if (e.key === '+' && e.ctrlKey) {
      e.preventDefault();
      pixelsPerMillisecond = Math.min(2, pixelsPerMillisecond * 1.1);
      document.getElementById('zoom-slider').value = pixelsPerMillisecond;
      updateZoomValue();
      renderGantt();
    } else if (e.key === '-' && e.ctrlKey) {
      e.preventDefault();
      pixelsPerMillisecond = Math.max(0.1, pixelsPerMillisecond * 0.9);
      document.getElementById('zoom-slider').value = pixelsPerMillisecond;
      updateZoomValue();
      renderGantt();
    }
  });

  // 初始渲染
  updateZoomValue();
  renderGantt();

  // 实时时钟更新
  setInterval(() => {
    const now = new Date();
    document.getElementById('current-time').textContent = formatTime(now);
    const clockMarker = graph.getCellById('clock-marker');
    if (clockMarker) {
      clockMarker.position((now - baseTime) * pixelsPerMillisecond, -10);
    }
  }, 100);
</script>
</body>
</html>
